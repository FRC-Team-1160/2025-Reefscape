package frc.robot;

import java.util.function.Supplier;

import com.pathplanner.lib.path.PathConstraints;
import com.pathplanner.lib.path.PathPlannerPath;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.wpilibj2.command.Command;

import frc.robot.Constants.PathConstants;

public class PathplannerController {
    
    public ChassisSpeeds generated_speeds;

    public Command current_command;

    public Supplier<Pose2d> robot_pose_supplier;

    public PathConstraints PATH_CONSTRAINTS;

    /** Creates a new PathplannerController. */
    public PathplannerController(Supplier<Pose2d> robot_pose_supplier) {
        this.robot_pose_supplier = robot_pose_supplier;

        generated_speeds = new ChassisSpeeds();
        current_command = new Command() {};

        PATH_CONSTRAINTS = new PathConstraints(
            PathConstants.MAX_SPEED, 
            PathConstants.MAX_ACCEL, 
            PathConstants.MAX_ANG_SPEED, 
            PathConstants.MAX_ANG_ACCEL);
    }

    /**
     * Stores the speeds generated by a Pathplanner command.
     * @param speeds The robot-relative chassis speeds.
     */
    public void acceptGeneratedSpeeds(ChassisSpeeds speeds) {
        generated_speeds = speeds;
    }

    /**
     * Wraps the initialize() method for the stored command.
     */
    public void cmdInitialize() {
        current_command.initialize();
    }

    /**
     * Wraps the execute() method for the stored command.
     */
    public void cmdExecute() {
        current_command.execute();
    }

    /**
     * Wraps the end() method for the stored command.
     * @param interrupted Whether the command was interrupted by isFinished().
     */
    public void cmdEnd(boolean interrupted) {
        current_command.end(interrupted);
    }

    /*
     * Wraps the isFinished() method for the stored command.
     */
    public boolean cmdIsFinished() {
        return current_command.isFinished();
    }
}
